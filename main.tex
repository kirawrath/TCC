\documentclass{ufscThesis/ufscThesis} % Definicao do documentclass ufscThesis	

%----------------------------------------------------------------------
% Pacotes usados especificamente neste documento
\usepackage{graphicx} % Possibilita o uso de figuras e gr�ficos
\usepackage{color}    % Possibilita o uso de cores no documento
\usepackage{listings}


\usepackage{amsmath}
\usepackage{multirow}
\usepackage{url}
%\usepackage{hyperref}
%----------------------------------------------------------------------
% Comandos criados pelo usu�rio
\newcommand{\afazer}[1]{{\color{red}{#1}}} % Para destacar uma parte a ser trabalhada

%----------------------------------------------------------------------
% Identificadores do trabalho
% Usados para preencher os elementos pr�-textuais
\instituicao[a]{Universidade Federal de Santa Catarina} % Opcional
\departamento[a]{INE}
\curso[a]{Universidade Federal de Santa Catarina}
\documento[a]{Tese} % [o] para disserta��o [a] para tese
\titulo{Portando o EPOS para a Zedboard}
%\subtitulo{Subt�tulo (se houver)} % Opcional
\autor{Bruno Farias de Loreto}
\grau{Bacharel em Ci�ncias da Computa��o}
\local{Florian�polis} % Opcional (Florian�polis � o padr�o)
\data{22}{Fevereiro}{2014}

\orientador[Orientador\\Universidade Federal de Santa Catarina]{Prof. Dr. Ant�nio Augusto Fr�hlich}
\coorientador[Coorientador\\Universidade Federal de Santa Catarina]{Prof. M.Sc. Giovani Gracioli}
\coordenador[Coordenador\\Universidade Federal de Santa Catarina]{Prof. Dr. Vit�rio Bruno Mazzola}

\numerodemembrosnabanca{4} % Isso decide se haver� uma folha adicional
\orientadornabanca{nao} % Se faz parte da banca definir como sim
\coorientadornabanca{sim} % Se faz parte da banca definir como sim
\bancaMembroA{Arliones Stevert Hoeller Junior\\Universidade Federal de Santa Catarina}
\bancaMembroB{Hugo Marcondes\\Universidade Federal de Santa Catarina}
%\bancaMembroC{... \\...}     % Nome do membro da Banca
%\bancaMembroD{... \\...}       % Nome do membro da Banca
%\bancaMembroE{Quinto membro\\Universidade ...}       % Nome do membro da Banca

%\dedicatoria{Este trabalho � dedicado a ...}

\agradecimento{Agrade�o �quele que morreu e ressucitou por n�s, Goku!}

\epigrafe{So long, and thanks for all the fish!\\\emph{- Douglas Adams.}}
%{(Autor da ep�grafe, ano)}

\textoResumo {
	No mundo dos sistemas operacionais embarcados, h� uma grande variedade de diferentes arquiteturas, e, consequentemente, um sistema operacional embarcado necessita dar suporte a um bom n�mero de arquiteturas para ser us�vel em diversos cen�rios. 
	O sistema operacional EPOS possui uma arquitetura que tenta ser o mais independente de plataforma poss�vel, entretanto o interfaceamento entre o software e hardware inevitavelmente necessita ser reescrito.
	Este trabalho visa descrever e documentar como o sistema operacional EPOS foi portado para a Zedboard, uma plataforma ARM \emph{multicore}.
}
\palavrasChave {Systemas Operacionais. Portabilidade. EPOS.}
 
\textAbstract {
	
}
\keywords {Operating Systems. Porting. EPOS.}

%----------------------------------------------------------------------
%Para gerar a lista de s�mbolos e abreviaturas use os comandos
%
%\simbolo{$\int$}{Integral}
%\simbolo{$\prod$}{Produt�rio}
%
%\begin{lstlisting}
%\simbolo{s�mbolo}{descri��o}
%\end{lstlisting}
%
%\begin{lstlisting}
%\abreviatura{abreviatura}{descri��o}
%\end{lstlisting}
%Segundo \citeonline{alves_2001} ...
%--------------------------------------------------------

\begin{document}

%\capa  
\folhaderosto%[comficha] % Se nao quiser imprimir a ficha, � s� n�o usar o par�metro
\folhaaprovacao
\paginadedicatoria
\paginaagradecimento
\paginaepigrafe
\paginaresumo
\paginaabstract
%\pretextuais % Substitui todos os elementos pre-textuais acima
\listadefiguras % as listas dependem da necessidade do usu�rio
\listadetabelas 
\listadeabreviaturas
%\listadesimbolos
\sumario

\abreviatura{SoC}{\emph{System-on-Chip}.}
\abreviatura{TCM}{\emph{Tightly Coupled Memory}}
\abreviatura{MMU}{\emph{Memory Management Unit}}
\abreviatura{SP}{\emph{Stack Pointer}}
\abreviatura{PC}{\emph{Program Counter}}
\abreviatura{LR}{\emph{Link Register}}
\abreviatura{CPSR}{\emph{Current Program Status Register}. O registrador que armazena o atual status do processador operante.}
\abreviatura{SPSR}{\emph{Saved Program Status Register}. (Registrador que armazena o valor de CPSR no momento imediatamente anterior ao acontecimento de uma exce��o, deste modo o antigo valor de CPSR pode ser restaurado quando a exce��o for tratada.}
\abreviatura{CP15}{\emph{System Control Coprocessor}}
\abreviatura{IRQ}{Interrup��o normal.}
\abreviatura{FIQ}{\emph{Fast Interrupt}.}
%\abreviatura{SCR}{\emph{ }}
\abreviatura{APSR}{\emph{Application Program Status Register}. Armazena uma c�pia do estado das \emph{flags} da unidade l�gico-aritim�tica. Conhecido tamb�m como \emph{flag} do c�digo condicional, usados para determinar se uma instru��o condicional deve ser executada ou n�o.}
\abreviatura{GIC}{\emph{Generic Interrupt Controler}}
\abreviatura{rx}{Quando a abrevia��o rx aparecer, ela estar� se referindo genericamente � qualquer um dos 13 primeiros registradores de prop�sito geral do ARM9 [r0-r12].}
\abreviatura{PPI}{\emph{Private Peripheral Interrupt.}}
\abreviatura{SGI}{\emph{Software Generated Interrupt.}}
\abreviatura{SPI}{\emph{Shared Peripheral Interrupt.}}
\abreviatura{PS}{\emph{Processing system.}}
\abreviatura{PL}{\emph{Programmable Logic.}}
\abreviatura{SMC}{\emph{Static Memory Controller}}
\abreviatura{TSC}{\emph{Time Stamp Counter.}}
\abreviatura{FPGA}{\emph{Field-Programmable Gate Array}. Hardware reconfigur�vel, o qual t�m as suas funcionalidades definidas exclusivamente pelos usu�rios.}
\abreviatura{PLL}{\emph{Phase-Locked Loop}. � um sistema de controle que gera uma sa�da cuja fase � relacionada � fase do sinal de entrada. Pode ser usada para estabilizar um sinal e tamb�m multiplica-lo.}
\abreviatura{SCU}{\emph{Snoop Control Unit}.}
%--------------------------------------------------------
% Elementos textuais

\chapter{Introdu��o}

O presente trabalho visa descrever como foi feito o porte\footnote{Porte � um estrangeirismo da palavra \emph{port}, que, no �mbito da computa��o, significa o ato de fazer um mesmo programa/sistema/SO funcionar em diferentes ambientes. Por exemplo, fazer um software que antes s� funcionava no Linux passar a funcionar em um outro SO (sistema operacional) pode ser considerado um porte. Uma palavra alternativa que poderia ser usada � ``suporte'', entretanto acredito que esta palavra n�o expresse apropriadamente o que foi feito, j� que essa palavra normalmente � associada com um servi�o pago de assist�ncia t�cnica, e o pr�prio fraseamento do que foi feito se tornaria de mais dif�cil compreens�o e prolixo com esta palavra.} do sistema operacional EPOS para a plataforma Zedboard, bem como comentar sobre as decis�es tomadas e problemas enfrentados.

\section{Motiva��o}
EPOS � um sistema operacional que visa reduzir o custo de produ��o das aplica��es embarcadas provendo um ambiente onde a aplica��o do desenvolvedor possa rodar sem que ele tenha que lidar com configura��es de baixo n�vel. Sendo assim � importante que o EPOS seja portado para um grande n�mero de plataformas, do contr�rio sua utilidade pr�tica seria prejudicada.

Zedboard � uma plataforma que usa o SoC Xilinx 7000, que por sua vez possui o processador \emph{dual core} ARM Cortex A9. Existe uma dupla motiva��o para se fazer o porte para esta plataforma: Primeiro que o EPOS ainda n�o foi portado para um processador RISC \emph{multicore}, e acredita-se que este porte poder� possibilitar linhas de pesquisa com o EPOS que antes s� poderiam ser feitos num CISC, algo que n�o � o ideal considerando-se o nicho de aplica��o do EPOS. O segundo fator est� relacionado com o pr�prio Zedboard. Dentro do LISHA (Laborat�rio de Integra��o Software-Hardware) h� uma linha de pesquisa sobre Smart Homes (ou Smart Buildings) em cujo contexto se pretende usar um Zedboard.

\section{Objetivos Gerais}

O objetivo deste trabalho � portar o sistema operacional EPOS e documentar este processo no presente documento. O porte consiste em adaptar os componentes que, dentro da arquitetura do EPOS, s�o chamados de mediadores de hardware. Cada mediador precisa ser refeito para cada plataforma.
Este trabalho ter� certo direcionamento para as pessoas que no futuro precisem fazer um novo porte do EPOS, de modo que elas n�o precisem passar pelos mesmos problemas e possam, portanto, fazer isto mais eficientemente.

\section{Objetivos Espec�ficos}
Dos objetivos espec�ficos, pode-se organiz�-los da seguinte forma:

\begin{enumerate}
    \item Estudo da arquitetura do EPOS, da arquitetura do ARM Cortex A9 e do Zedboard.
    \item Portes
    \begin{enumerate}
        \item Timers
        \item Controlador de Interrup��o
        \item MMU
        \item CPU
        \item Inicializa��o elf e Multicore
    \end{enumerate}
    \item Valida��es
    \begin{enumerate}
        \item Escalonadores em single e multicore
        \item Threads
        \item Thread Peri�dica
        \item Alarmes
        \item Cron�metro
        \item Sincroniza��o
    \end{enumerate}
    \item Documenta��o
\end{enumerate}

\chapter{Conceitos B�sicos}

%source: http://epos.lisha.ufsc.br/EPOS+User+Guide
\section{EPOS}

EPOS (Embedded Parallel Operating System) � um sistema operacional orientado a aplica��o, cujo design chama-se ADESD (\emph{Application-Driven Embedded System Design Method}), proposto por Fr�hlich \cite{guto_thesis}. A ideia central do EPOS � prover um sistema operacional m�nimo, de modo a minimizar o \emph{overhead} da exist�ncia de um sistema operacional, deixando o processador livre para executar a aplica��o do desenvolvedor \cite{epos_user_guide}.

Como o objetivo � criar um ambiente em que o desenvolvedor possa rapidamente produzir suas aplica��es, EPOS prov� v�rios utilit�rios comumente usados em aplica��es, como filas, listas, tabelas de hashs, vetores, sem�foros, OStream (para imprimir na tela), n�meros aleat�rios, c�lculo de CRC e etc. Al�m destes utilit�rios, EPOS tamb�m prov� uma s�rie de componentes como threads, alarmes, cronometros, heaps e meios para acessar a rede (internet).

\section{Arquitetura do EPOS}

\textbf{Mediadores de Hardware:} Dentro da arquitetura do EPOS h� o conceito de mediadores de hardware, que s�o os componentes (ou classes) dependentes de plataforma. Idealmente, as �nicas classes que precisam ser modificadas e/ou reimplementadas s�o os mediadores. H� mediadores espec�ficos da placa, como por exemplo Pandaboard, Zedboard e etc; abstra�dos sob o nome de \emph{machine} e mediadores espec�ficos de um processador, abstra�dos sob o nome de \emph{architecture}. No c�digo do EPOS, estes mediadores encontram-se nas pastas \emph{mach} e \emph{arch}.
% Fonte: Hardware Mediators: A Portability Artifact for Component-based Systems
% HAL vs Virtualiza��o vs Mediadores

Mediadores de hardware s�o uma alternativa ao tradicional uso de VMs\footnote{Virtual Machines.} e de HAL\footnote{Hardware Abstraction Layer}, proposta por Fr�hlich em seu trabalho \emph{Application-Oriented System Design} \cite{guto_thesis}. O problema do uso de VMs � o seu \emph{overhead} causado devido � tradu��o das opera��es da VM em c�digo nativo. J� o uso de um HAL incorre no problema da manutenibilidade e dificuldade de adap��o � novas arquiteturas muito distintas entre si \cite{hw_mediators}. O HAL n�o conseguiu passar pela prova do tempo, e j� est� sendo considerado obsoleto por distribui��es GNU/Linux populares, como o 
Ubuntu\footnote{\url{http://www.linux-magazine.com/Online/News/Ubuntu-10.04-Alpha-2-Removes-HAL}}, sendo chamado de ``uma grande n�o-manuten�vel bagun�a monol�tica''\footnote{\url{https://wiki.ubuntu.com/Halsectomy}}.



\textbf{Traits:} Traits � uma classe onde � poss�vel configurar certos componentes do EPOS em tempo de compila��o. L� � poss�vel, por exemplo, definir o tamanho da stack e heap do sistema, a sua frequ�ncia de clock bem como ativar ou desativar certas fun��es do sistema. Esta classe normalmente precisa ser alterada em um porte, mesmo ela n�o sendo um mediador de hardware.

\textbf{Interface Infladas: } Um conceito importante da arquitetura do EPOS � a Interface Inflada. %http://www.inf.ufsc.br/~guto/publications/aoos.pdf
Em sistemas orientados a aplica��o, fam�lias de abstra��es s�o frequentemente tratadas como entidades �nicas, algo que pode ser vantajoso para o programador da aplica��o, j� que este n�o precisaria se preocupar com qual membro em espec�fico desta fam�lia ele precisaria usar\cite{guto_thesis}.

Interface inflada basicamente � uma interface que declara os m�todos de todas as classes que derivam dela, exportanto assim todos os m�todos daquela fam�lia de abstra��es. Deste modo, o desenvolvedor de aplicativo poderia escrever a aplica��o inteira em termos da interface inflada, relegando a tarefa de configura��o do sistema a um utilit�rio automatizado. Tal utilit�rio poderia, atrav�s de uma an�lise sint�tica do c�digo fonte, escolher quais os membros mais leves da fam�lia exportada ser�o associados no momento da compila��o \cite[p.~56]{guto_thesis}.

%write about specifics from timers
\begin{figure}[ht!]
    \centering
    \includegraphics[width=7.5cm]{figuras/inflated_interface}
    \caption{Exemplos de uso de interfaces infladas \cite{guto_thesis}.}
\end{figure}


\section{Hardware-alvo}
%source: http://www.zedboard.org/product/zedboard
% http://www.zedboard.org/sites/default/files/documentations/ZedBoard_HW_UG_v2_2.pdf
Zedboard � uma plataforma de desenvolvimento que suporta uma grande variedade de aplica��es, visto que ela possui uma boa gama de interfaces e fun��es para habilitar isto. � dedicada � prototipa��o e \emph{proof-of-concept}. Em seu interior ela possui um Xilinx Zynq 7000 (Z-7020), que � a arquitetura alvo deste porte.

O ZYNQ-7000 SOC XC7Z020-CLG484-1 conta com o processador Dual ARM Cortex-A9 MPCore. O Zynq possui 4 gradua��es de velocidade de \emph{clock}, a comercial (gradua��o -1), industrial (gradua��o -1 a -2), estendida (-2 a -3) e expandida (-1), sendo a gradua��o -1 a menor velocidade, e a -3 a maior \cite{product_table}.

De acordo com a especifica��o da Zedboard \cite{zedboard}, o \emph{clock} m�ximo do processador � de 667MHZ, portanto, tendo como refer�ncia a tabela de dados do Zynq-7000 \cite[p.~13]{data_sheet}, chegamos � conclus�o que a gradua��o de velocidade do Zynq usado na Zedboard � de -1 (comercial), esta informa��o se tornar� �til mais � frente.

H� dispon�vel 512MB de RAM DDR3, e um SD card de 4GB. A Zedboard suporta conex�o com JTAG, sa�da serial (USB UART) e conex�o com a internet \cite{xilinx}.

A fam�lia Zynq 7000 disponibiliza para o desenvolvedor FPGAs, tornando esta plataforma mais configur�vel e flex�vel \cite[p.~26]{ug585}. A PS dessa fam�lia � a mesma para cada dispositivo onde ela se encontra, entretanto a PL e recursos de entrada e sa�da variam entre diferentes dispositivos. 


\begin{figure}[ht!]
    \centering
    \includegraphics[width=8cm]{figuras/zedboard}
    \caption{Zedboard visto de cima.}
\end{figure}

\subsection{Arquitetura do Zynq 7000}
Como j� citado, o Zynq 7000 possui um processador \emph{dual core}Cortex A9, cada core possui sua pr�pria MMU e mem�ria cache L1 (instru��es e dados) privada.

%layout de memoria
\subsection{OCM} O \emph{On-chip Memory} � uma pequena mem�ria de 256KB de RAM que fica pr�xima ao processador, e portanto tem um acesso mais r�pido. O OCM pode ser mapeado nos primeiros 256KB do espa�o de endere�amento, ou nos �ltimos 256KB do espa�o de endere�amento \cite{ug585}, como mostrado na tabela \ref{tab.memlayout}.


\subsection{Layout de mem�ria} 
A tabela abaixo � uma simplifica��o do layout de mem�ria do Zynq\footnote{Uma tabela mais completa e detalhada pode ser encontrada em UG585 (v1.6.1), p. 115.}.

\begin{table}[ht]

\centering
\begin{tabular}{ccp{5cm}}
\hline\hline                        %inserts double horizontal lines
Intervalo de endere�o  & Regi�o mapeada & Coment�rios\\ [0.5ex] % inserts table 
%heading
\hline                  % inserts single horizontal line
\verb+0x0000_0000 - 0x0003_FFFF+ & OCM & \parbox{5cm}{OCM quando mapeada em \\mem�ria baixa (padr�o).} \\
\verb+0x0010_0000 - 0x3FFF_FFFF+ & DDR &  \\
\verb+0x4000_0000 - 0xFFFB_FFFF+ & V�rias & \parbox{5cm}{Registradores mapeados em \\mem�ria ou �reas reservadas.} \\
\verb+0xFFFC_0000 - 0xFFFF_FFFF+ & OCM & \parbox{5cm}{OCM quando mapeada em \\mem�ria alta.}\\ [1ex]
\hline %inserts single line
\end{tabular}
\caption{Mapeamento de mem�ria.}
\label{tab.memlayout} % is used to refer this table in the text
\end{table}

A parte que nos interessa � saber que a RAM come�a em \verb+0x0010_0000+ (1MB) e termina em \verb+0x3FFF_FFFF+ (1GB). � �bvio que apesar do mapeamento ir at� 1GB, o sistema est� limitado a quanto de mem�ria f�sica existe, que no caso s�o 512MB.




\subsection{Modos de Opera��o}
\label{sec:operating_modes}
A arquitetura ARMv7 conta com 9 modos de opera��o (7 por padr�o, mais 2 com extens�es habilidadas), sendo que o �nico modo n�o privilegiado � o modo de usu�rio, os demais modos padr�o possuem o mesmo privil�gio dentro do sistema. A principal diferen�a entre um modo e outro � que cada modo conta com um certo subconjunto privado de registradores, visiveis somente no modo em vig�ncia, detalhes sobre estes registradores seguem na se��o seguinte. A tabela abaixo ilustra quais s�o os modos de opera��o dispon�veis \cite[p.~1139]{armarm}.
O campo ``Codifica��o'' � usado no registrador CPSR para se verificar ou modificar o modo de opera��o.

\begin{table}[ht]
\centering
\begin{tabular}{ccc}
\hline\hline                        %inserts double horizontal lines
Modo do processador  & Codifica��o & Implementado?\\ [0.5ex] % inserts table 
%heading
\hline                  % inserts single horizontal line
User & 10000 & Sempre \\
FIQ & 10001 & Sempre \\
IRQ & 10010 & Sempre \\
Supervisor & 10011 & Sempre\\
Monitor & 10110 & Com exten��es de seguran�a.\\
Abort & 10111 & Sempre\\
Hyp & 11010 & Com exten��es de virtualiza��o.\\
Undefined & 11011 & Sempre\\
System & 11111 & Sempre\\[1ex]
\hline %inserts single line
\end{tabular}
\caption{Modos do processador.}
\label{tab.processormode} % is used to refer this table in the text
\end{table}

\textbf{Modo Usu�rio:} Modo n�o-privilegiado de execu��o. Neste modo somente � poss�vel de se fazer acesso n�o privilegiado aos recursos do hardware (n�o prodendo acessar as �reas protegidas). N�o � poss�vel de se mudar para outro modo de opera��o quando neste, a n�o ser por eventos externos como interrup��es.

\textbf{Modo Sistema:} Modo privilegiado de execu��o. Este modo usa os mesmos registradores que o modo usu�rio e nenhuma exce��o leva a este modo. Somente � poss�vel de se entrar nesse modo alterando os bits do registrador de status do sistema (CPSR); � necess�rio j� estar em algum modo privilegiado para tal opera��o.

\textbf{Modo Supervisor:} � o modo padr�o para no qual processador entra quando exce��o do tipo \emph{Supervisor Call} � recebida.
Para gerar um \emph{Supervisor Call}, usa-se a instru��o \verb+svc+. O processador entra neste modo ao se resetar.

\textbf{Modo Abort:} Modo que o processador entra quando recebe uma interrup��o do tipo \emph{prefetch abort} ou \emph{data abort}.

\textbf{Modo Indefinido:} Modo que o processador entra quando se tenta executar uma instru��o n�o definida.

\textbf{Modo FIQ:} Modo que o processador entra quando recebe uma interrup��o FIQ.

\textbf{Modo IRQ:} Modo que o processador entra quando recebe uma interrup��o IRQ.

\textbf{Modo Hipervisor:} Este modo possui ainda mais privil�gios que os demais modos, mas somente existe quando as exten��es de virtualiza��o est�o ativas (fora do escopo deste trabalho).

\textbf{Modo Monitor:} Modo que o processador entra quando recebe uma interrup��o \emph{Secure Monitor Call}, \verb+SMC+. Este modo est� fora do escopo do trabalho.


\begin{figure}[ht!]
	\centerline{
    \includegraphics[width=12cm]{figuras/banked_registers}
	}
    \caption{Banked registers.}
\end{figure}



\subsection{GIC}
O GIC (\emph{Generic Interrupt Controller}) � um componente que centraliza e administra todas as interrup��es do sistema, ativando, desativando, mascarando e priorizando as fontes de interrup��o.


\subsection{Tipos de Interrup��o} %ug585 p. 192
\label{sec:interrupt}
\textbf{Interrup��o Gerada por Software: }
Cada CPU pode se interromper, interromper outra CPU, ou ambas CPUs usando SGIs (\emph{Software Generated Interrupts}). Existem 16 interrup��es geradas por software, que podem ser geradas escrevendo o n�mero da interrup��o ([0-15]), junto com o n�mero da CPU alvo no registrador ICDSGIR. Esta escrita ocorre dentro do barramento privado da pr�pria CPU. Cada CPU possui seu pr�prio conjunto privado de registradores de SGIs para gerarem uma (ou mais) das 16 SGIs poss�veis. � poss�vel limpar uma interrup��o lendo o registrador ICCIAR (\emph{Interrupt Acknowledge}) ou escrevendo 1 nos bits correspondentes do registrador ICDICPR (\emph{Interrupt Clear-Pending}).
\\\\
\textbf{Interrup��es de Perif�ricos Privados da CPU: }
Cada CPU est� conectada a um conjunto privado de 5 interrup��es de perif�ricos, s�o eles: Rel�gio Global (\emph{Global Timer}), nFIQ (\emph{Fast Interrupt}), Rel�gio privado da CPU, \emph{Watchdog} privado da CPU e nIRQ (interrup��o vinda da l�gica program�vel).
\\\\
\textbf{Interrup��es de Perif�ricos Compartilhados: }
Existem cerca de 60 interrup��es de diversos modulos que podem ser roteadas para um ou ambos processadores, ou para a l�gica program�vel. O GIC � respons�vel por administrar estas interrup��es.

\begin{figure}[ht!]
	\centerline{
    \includegraphics[width=13cm]{figuras/zynq-7000}
	}
    \caption{Diagrama de blocos dos \emph{clocks} dispon�veis no Zynq. Note os \emph{clocks} da tabela \ref{tab:clocks} no canto superior direito da imagem.}
\end{figure}


\subsection{(\emph{timers})}
Cada um dos \emph{cores} possui um \emph{timer} privado de 32 bits e ambos \emph{cores} compartilham um \emph{timer} global de 64 bits. Estes \emph{timers} trabalham numa frequ�ncia sempre igual � metade da frequ�ncia da CPU.
No n�vel de sistema (\emph{sistem-level (PS)}), h� dois \emph{timers} triplos, cujas frequ�ncias s�o sempre um quarto ou um sexo da frequ�ncia da CPU.




\subsection{\emph{Clocks}}

%30 <= PS_CLK <= 60MHZ
O \emph{clock} principal do sistema, chamado aqui de PS\_CLK (\emph{Processing System Clock}), � respons�vel por alimentar as 3 PLLs do sistema, sendo cada uma dessas PLLs respons�vel por uma parte diferente do sistema\cite[p.~622]{ug585}. O PS\_CLK � um \emph{clock} de baixa frequ�ncia, ficando entre 30 a 60 MHz (PS\_CLK � igual a 33.33 MHz no caso da Zedboard), sendo este multiplicado por cada uma das 3 PLLs\footnote{\emph{Phase-Locked Loop}. � um sistema de controle que gera uma sa�da cuja fase � relacionada � fase do sinal de entrada. Pode ser usada para estabilizar um sinal e tamb�m multiplica-lo.} para que o sistema funcione com velocidades maiores\footnote{Este clock pode ser multiplicado por um n�mero de 1 a 127, e � multiplicado por 26 por padr�o}. As 3 PLLs s�o:

\begin{itemize}
	\item \textbf{I/O PLL:} Respons�vel por produzir o sinal de \emph{clock} para os dispositivos de entrada e sa�da.
	\item \textbf{DDR PLL:} Respons�vel por produzir o sinal de \emph{clock} para as mem�rias da plataforma.
	\item \textbf{ARM PLL:} Respons�vel por produzir o sinal de \emph{clock} o restante do sistema, incluindo os processadores.
\end{itemize}

A FPGA da Zedboard possui um \emph{clock} pr�prio e exclusivo.

A Zedboard pode operar em dois modos (ou velocidades), denominados pela pela raz�o 6:3:2:1 e 4:2:2:1, abreviados como 6:2:1 e 4:2:1. Para alternar entre estes dois modos de velocidade, basta escrever 1 ou 0 no registrador CLK\_621\_TRUE. Estes n�meros indicam quantas vezes cada \emph{clock} multiplica o \emph{clock} de base CPU\_1x, sendo este CPU\_1x um \emph{clock} derivado da ARM PLL, dividido por algum fator (configur�vel).

H� 4 \emph{clocks} independentes, chamados de CPU\_6x4x, CPU\_3x2x, CPU\_2x e CPU\_1x. Esta nomenclatura dos \emph{clocks} indica o fator pelo qual o CPU\_1x � multiplicado em cada modo.
A o primeiro n�mero do nome indica o fator multiplicativo daquele \emph{clock} no modo 6:2:1, e o segundo n�mero indica o fator multiplicativo no modo 4:2:1.
Por exemplo, no modo \textbf{6}:2:1, o CPU\_\textbf{6x}4x multiplica o CPU\_1x 6 vezes, e no modo \textbf{4}:2:1, o CPU\_6x\textbf{4x} multiplica o CPU\_1x 4 vezes. A tabela \ref{tab:clocks} ilustra a velocidade de cada \emph{clock} em cada um dos dois modos.

\begin{table}[ht]
	\centering
	\begin{tabular}{ccc}
		\hline\hline
		Nomenclatura & \emph{Clock Ratio} & M�xima frequ�ncia da CPU\\[0.5ex]
		\hline
		CPU\_6x4x & \multirow{4}{*}{6:3:2:1} & 667 MHZ\\
		CPU\_3x2x &                          & 333 MHZ\\
		CPU\_2x   &                          & 222 MHZ\\
		CPU\_1x   &                          & 111 MHZ\\
		\hline
		CPU\_6x4x & \multirow{4}{*}{4:2:2:1} & 533 MHZ\\
		CPU\_3x2x &                          & 267 MHZ\\
		CPU\_2x   &                          & 267 MHZ\\
		CPU\_1x   &                          & 133 MHZ\\[1ex]
		\hline
	\end{tabular}
	\caption{M�ximas frequ�ncias poss�veis para cada configura��o de \emph{clock}. Para uma lista mais completa (com as diferentes gradua��es de \emph{clock}), veja \cite[p.~13]{data_sheet}.}
	\label{tab:clocks}
\end{table}

\begin{figure}[ht!]
    \centering
    \includegraphics[width=8cm]{figuras/zedboard}
	\caption{Arquitetura do Zynq 7000.}
\end{figure}

\subsection{UART}
A UART (Universal Asynchronous Receiver/Transmitter) � um componente que trata da sa�da e entrada serial do sistema, portanto sendo o componente respons�vel por transmitir e receber caracteres, sendo necess�rio para impress�o em tela, o que pode ser feito tanto por meio de um conector VGA quanto por USB (usado principalmente para depura��o do c�digo). As duas principais fun��es na classe da UART dentro do EPOS s�o justamente a put e get, para impress�o e leitura de caractere, respectivamente. O Zynq possui duas UARTs.



\subsection{MMU} %http://epos.lisha.ufsc.br/EPOS+User+Guide#MMU

A MMU (\emph{Memory Managemed Unit}) � um componente respons�vel por gerenciar a mem�ria de um sistema. � este componente o respons�vel por traduzir o endere�amento l�gico em endere�amento f�sico. Uma das principais vantagens de seu uso � a possibilidade de prote��o de mem�ria.

%%%%%%%%
%		Get image from ug585 v1.7 p.79!
%%%%%%%%
\section{Ambiente de Desenvolvimento}

O ambiente de desenvolvimento usado para o porte foi o qemu para ARM (\verb+qemu-system-arm+), para executar o EPOS num ambiente virtualizado (emulado), pois assim pode-se usar ferramentas como o GDB para a depura��o do c�digo. O uso do GDB foi fundamental para o desenvolvimento, j� que com ele era poss�vel imprimir o valor de cada registrador em um dado ponto da execu��o, verificar a mem�ria, executar instru��es espec�ficas e etc. Para compilar o EPOS foi usado \emph{cross-compilers} para ARM. As flags usadas para criar um ambiente de depura��o com o qemu e o GDB foram as sequintes (com cada comando feito em um terminal diferente):
\begin{verbatim}
	qemu-system-arm -no-reboot -nographic -s -S -machine xilinx-zynq-a9\
	-cpu cortex-a9 -kernel ./img/zynq_app -fda ./img/zynq_app.img

	arm-none-eabi-gdb -ex "target remote :1234"
\end{verbatim}

O hardware real tamb�m estava dispon�vel, e foi usado quando quando o qemu n�o produzia resultados confi�veis. Com o hardware real, para a depura��o do c�digo foi usado o JTAG.

\chapter{Porte}

% Eu poderia descrever como eu tenho que incluir cada classe feita em ./include/system/types.h, op��es de traits, etc..


Nesta se��o ser� discutido como foi o porte de cada mediador de hardware, explicando as decis�es e dificuldades encontradas.

Antes de entrar nas especificidades de cada componente, � interessante colocar aqui alguns conceitos comuns que s�o usados em cada mediador.

A maneira usada para se comunicar, configurar e ler o estado de um dado componente de hardware � atrav�s da leitura e/ou escrita em registradores mapeados em mem�ria. Um registrador mapeado em mem�ria basicamente � uma regi�o fixa da mem�ria, onde uma escrita naquela posi��o indica uma escrita no registrador l� mapeado.
Exemplificando, a UART possui um registrador chamado rcvr\_timeout\_reg0, respons�vel por indicar quantos ciclos\footnote{Na realidade � o n�mero de baud\_samples que se passaram.} a UART deve esperar um novo caractere chegar antes de emitir uma interrup��o de \emph{timeout}. Este registrador est� mapeado na posi��o de mem�ria 0xE000001C para a UART0. Portanto, para configurar que o n�mero de ciclos esperado seja de 20, basta escrever este n�mero naquela posi��o. Uma maneira de fazer esta escrita, por exemplo, em C/C++, �: \verb+*((unsigned long*)0xE000001C) = 20;+.

%\section{memory map}

%\section{Boot}

\section{Traits}

Existem 4 arquivos traits.h que devem ser levados em considera��o em um porte, dois deles devem ser completamente reescritos. Os arquivos \verb+./include/traits.h+ e \verb+/include/system/traits.h+ (onde '.' � a pasta raiz do c�digo) possuem configura��es gerais do EPOS, que, a princ�pio, devem ser independentes de arquitetura. Na pr�tica h� alguns pequenos ajustes que devem ser feitos nesses arquivos, pois � l� que se define, por exemplo, se o EPOS trabalhar� em um processador \emph{multicore}, se utilizar� \emph{scratchpad}, quais componentes estar�o em modo de depura��o e etc; entretanto isto se resume a trocar o valor de algumas vari�veis de \emph{true} para \emph{false} ou o contr�rio.

Os outros dois arquivos s�o \verb+./include/mach/zynq/traits.h+ e \verb+./include/arch/armv7/traits.h+. Essa divis�o � necess�ria pois, como dito anteriormente, � poss�vel de um mesmo processador estar em diferentes \emph{machines}, e, caso seja necess�rio fazer um porte para esta plataforma, bastaria modificar os arquivos da pasta \emph{mach}, deixando os da pasta \emph{arch} praticamente int�ctos, o que facilita muito novos portes.

Em \verb+./include/arch/armv7/traits.h+ trata das op��es espec�ficas do processador, portanto � l� que op��es como \emph{endianess}, velocidade de \emph{clock}, n�mero de \emph{cores}, tamanho da heap e stacks, bem como outras op��es pertinentes ao mapeamento de mem�ria e op��es da MMU podem ser configuradas.

No arquivo de traits da \emph{machine}, ficam as op��es de configura��o de componentes como a UART, controlador de interrup��es, \emph{timer}, e qualquer componente de interfaceamento externo � placa (rede, por exemplo). Componentes podem ser facilmente desativados nestas op��es.

\section{Metaprograma��o est�tica}

A arquitetura do EPOS usa pesadamente de metaprograma��o est�tica para, em tempo de compila��o, selecionar a arquitetura, bem como cada componente que ser� ou n�o utilizado. Por exemplo, podemos definir um \emph{if} est�tico para selecionar de qual classe a classe Chronometer ir� derivar. Primeiramente a defini��o do \emph{if}:

\begin{verbatim}
template<bool condition, typename Then, typename Else> struct IF
{
    typedef Then Result;
};
\end{verbatim}

Este template, a princ�pio, nada mais faz do que tomar 3 par�metros e ent�o criar um tipo chamado Result igual ao segundo par�metro, entretanto se n�s fizemos uma especializa��o deste template, ele passa ser �til:

\begin{verbatim}
template<typename Then, typename Else> struct IF<false, Then, Else>
{
    typedef Else Result;
};
\end{verbatim}

Com esta especializa��o, toda vez que o primeiro par�metro resolver-se como falso, Result ser� definido como o terceiro par�metro. Temos, portanto, um \emph{if} metaprogramado funcional, agora voltemos ao exemplo do chronometro.

Suponha que caso a arquitetura n�o seja multicore, e nos traits o TSC (\emph{time stamp clock}) esteja ativo, ent�o deseja-se que Chronometer derive de TSC\_Chronometer, do contr�rio de Alarm\_Chronometer.

Isto pode ser feito usando nosso \emph{if} metaprogramado da seguinte forma:

\begin{verbatim}
class Chronometer: public
IF<Traits<TSC>::enabled && !Traits<System>::multicore,
TSC_Chronometer, Alarm_Chronometer>::Result
{//class body};
\end{verbatim}

Deste modo, Chronomometer derivar� de IF::Result, que ser� resolvido como TSC\_Chronometer ou Alarm\_Chronometer. Note que esse exemplo tamb�m mostra um uso do Traits, onde para descobrir se o TSC est� ativo, bastou ler a constante Traits<TSC>::enabled, e para saber se o sistema � multicore bastou ler Traits<System>::multicore. Todo esse processamento causa zero \emph{overhead} em tempo de execu��o.

\section{Porte da UART}

A inicializa��o da UART foi feita de acordo com o sugerido pelo manual em \cite[p.~554]{ug585}. Nesta se��o ser� comentado as decis�es tomadas na configura��o inicial da UART, em particular por causa dos momentos em que o manual exigia que o desenvolvedor tomasse uma decis�o.

A primeira decis�o que foi necess�ria � a de escabelecer qual ser� a taxa de transmiss�o (\emph{Baud Rate}) da UART. 

\begin{figure}[ht!]
    \centering
    \includegraphics[width=10cm]{figuras/uart_board_rate}
    \caption{Esquem�tico de como � criada a taxa de transmiss�o.}
	\label{fig:uart}
\end{figure}

Primeiramente foi necess�rio configurar o \emph{clock} de refer�ncia da UART. Para isto, deve-se dividir o \emph{clock} que vem do I/O PLL (que por sua vez deriva do PS\_CLK, que � o \emph{clock} geral do sistema). Recomenda-se dividir o \emph{clock} da I/O PLL de modo a se obter 50 ou 33 MHz.
O \emph{clock} da I/O PLL, por padr�o, multiplica o PS\_CLK (de 33.33 MHz) por 26, resultando num \emph{clock} de 866 MHz.
No manual diversas vezes � usado como exemplo para o \emph{clock} de refer�ncia da UART 50 MHz, portanto, arbitrariamente, escolheu-se esse valor. Logo, deve-se configurar o registrador UART\_CLK\_CTRL, respons�vel por configurar o \emph{clock} de entrada da UART, para dividir este \emph{clock} vindo da I/O PLL por 17 ($866/17 = 50$).

Agora, com este \emph{clock} estabelecido, que vamos chamar de sel\_clk (de acordo com a nomenclatura do manual), devemos calcular quanto ser� a taxa de transmiss�o.
Ap�s alguma pesquisa em f�runs de desenvolvedores de software b�sico, notei que uma taxa de transmiss�o de 9600 bps � o mais comum, portanto, assumindo este valor, a pr�xima etapa � configurar os dois divisores de \emph{clock} que ajustam a taxa de transmiss�o, como indicado na figura \ref{fig:uart}.

O primeiro divisor chama-se CD (\emph{clock divider}), que configura a constante para se dividir o \emph{clock}, e BDIV um segundo divisor usado para sobreamostragem, organizado como mostrado na figura \ref{fig:uart}. O valor da taxa de transmiss�o final � calculado da seguinte forma:
\begin{equation}
	\text{taxa de transmiss�o} = \frac{sel\_clk}{CD \times (BDIV+1)}
\end{equation}

O valor padr�o de BDIV � 15, portanto, fixiando-se esse valor e resolvendo a equa��o por CD, temos que $CD = 325$. Configurando-se estes valores nos seus respectivos registradores, obt�m-se a taxa de transmiss�o desejada de 9600 bps.

Ap�s estas configura��es, dentre outras que o manual descreve, a UART est� pronta para ser usada. Os dois principais m�todos usados da UART s�o o put e o get, o primeiro escreve um caractere na sa�da serial, sendo que este pode ser lido, por exemplo atrav�s de uma entrada USB, para imprimir estes caracteres numa tela; algo muito �til para depura��o.

\section{Porte do \emph{timer}}



Um \emph{timer} permite contar um certo n�mero de ciclos, e, ao final da contagem, ele emite uma interrup��o ao GIC, para que ent�o o processador trate este evento. Entretanto note que � poss�vel de existir mais \emph{timers} sendo usados logicamente do que \emph{timers} f�sicos dispon�veis, significando que um mesmo \emph{timer} deve conseguir servir a mais de uma requisi��o simultaneamente.

Portanto n�o podemos apenas configurar um \emph{timer} para contar initerruptamente at� passar o tempo que desejamos, do contr�rio novas requisi��es sobreescreveriam a anterior. Para ilustrar, suponha que se queira contar por 10 segundos, como o \emph{clock} do \emph{timer} � de 333 MHz (periodo $1/333 \times 10^6$), bastaria configurar o \emph{timer} para contar por $10 \times 333 \times 10^6$ ciclos e ent�o chamar o \emph{handler} associado a interrup��o gerada quando o \emph{timer} chegar em zero.

Agora imagine que, no cen�rio acima, enquanto o \emph{timer} ainda est� servido �quela solicita��o de contagem, apare�a outra solicita��o, de um alarme por exemplo, e queria contar por 20 segundos. Se esta solicita��o sobrescrever o registrador de configura��o do \emph{timer}, a solicita��o anterior n�o ter� seu pedido atendido a tempo. Note tamb�m que o escalonador de processos tamb�m estar� usando este \emph{timer}.

Para resolver este problema, na arquitetura do EPOS existe o conceito de ticks (algo parecido com o que se faz no Linux), onde se configura um \emph{timer} para gerar interrup��es em um intervalo regular, intervalo este que deve ser pequeno o suficiente para poder atender a demanda de contagens de pequenos valores, assim como n�o ser pequeno demais ao ponto de gastar mais processamento tratando as interrup��es geradas pelo \emph{timer} do que servindo � outras fun��es. Assim, cada objeto que instancia (ou usa) um \emph{timer}, como o Alarm, Scheduler e Chronometer, nunca realmente tocam em algum registrador do \emph{timer} (portanto esses componentes s�o independentes de arquitetura), e, no lugar disso, computam quantos ticks, isto �, quantas interrup��es de \emph{timer} aconteceram.

Para exemplificar o funcionamento destes componentes, tomemos o escalonador de processos. No construtor do escalonador, � enviado como par�metro o periodo de escalonamento, ou seja, quanto tempo (no m�ximo) uma thread pode executar antes de ser escalonada. Para se saber quantos ticks devem ser contados antes de se escalonar um processo, basta dividir a frequ�ncia em que os ticks incrementam, pela frequ�ncia de escalonamento. Por exemplo, se o timer gera uma interrup��o a cada 1 milisegundo (1000 Hz), e o escalonador escalona um processo a cada 10 milisegundos (100 Hz), o n�mero de ticks a se contar � $1000/100 = 10$ ticks. Estes s�o os valores usados na implementa��o tamb�m.

No caso do Alarm em espec�fico, internamente h� uma fila com todas as requisi��es de alarme, ordenado do menor tick ao maior. Quando ocorre uma interrup��o de timer, � chamado primeiramente o \emph{handler} que gerencia esta fila, e, caso um alarme desta fila j� tenha esperado os ticks que requisitou, ent�o o \emph{handler} desse alarme � chamado (este \emph{handler} � definido pelo usu�rio que instanciou o alarme).


O construtor do \verb+Zynq_Timer+ recebe como par�metro a frequ�ncia que o contador deve contar, assim como o \emph{handler} que deve ser chamado quando esta contagem terminar (isto �, a fun��o chamada quando acontecer uma interrup��o devido ao timer ter chego a zero), e um n�mero chamado channel, que serve para demultiplexar qual handler deve ser chamado.

A classe \verb+Zynq_Timer+ possui um atributo est�tico (e portanto �nico para todas as inst�ncias) definido como \verb+Zynq_Timer*+ \verb+_channels[CHANNELS]+, onde \verb+CHANNELS+ � uma constante com o n�mero de diferentes classes usando o \emph{timer} (Scheduler e Alarm). Este vetor � necess�rio pois, quando uma interrup��o de \emph{timer} acontece e o \emph{handler} do \emph{timer} � chamado, o \emph{handler} pode iterar sobre ele, chamando todos os respectivos \emph{handlers} daquelas classes.


Os 4 principais registradores a se trabalhar para configurar o \emph{timer} s�o o \verb+load+, registrador onde se escreve por quantos ciclos se deve contar; o \emph+counter+, que � o registrador que cont�m o atual valor contado, sendo decrementado a cada ciclo at� chegar em zero, chegando em zero o � gerada uma interrup��o n�mero 29; registrador \emph+control+, que permite configurar certos comportamentos do \emph{timer}, como o de ativa-lo, ativar modo c�clico, ativar interrup��es e atribuir um valor para o \emph{prescale}; e finalmente o registrador \emph+interrupt status+, que, como o nome indica, permite que se leia o status das interrup��es de timer. Todos os timers trabalham � metade do \emph{clock} do sistema, ou seja, usando o \emph{clock} CPU\_3x2x.

Durante a inicializa��o do sistema, o \emph{timer} � configurado para gerar interrup��es periodicamente, e esta configura��o n�o � alterada durante a execu��o da aplica��o. Como o construtor do \verb+Zynq_Timer+ recebe uma frequ�ncia como par�metro, � necess�rio se converter esta frequ�ncia para um n�mero de ciclos a se contar. Para isto, � necess�rio se levar em conta a frequ�ncia com que o contador � decrementado, para ent�o se definir um valor a ser decrementado periodicamente de modo a fornecer a frequ�ncia desejada.

Como sabemos que o \emph{clock} ao qual o \emph{timer} est� submetido � metade do \emph{clock} do sistema, e que antes dele chegar ao contador, este mesmo clock � dividido por um divisor chamado \emph{prescaler} (que divide pelo valor configurado nele mais 1), podemos dizer que:
\[
	COUNTER\_CLOCK\_FREQUENCY = \frac{SYSTEM\_CLOCK}{2 \times (PRESCALER+1)}
\]
Logo, usando a mesma linha de racionc�nio exposta no exemplo de c�lculo de ticks, temos que o valor a ser carregado no \verb+load_register+ (que ser� chamado de \verb+load_value+), sendo a frequ�ncia desejada F, �:
\begin{equation}
	\text{load\_value} = \frac{SYSTEM\_CLOCK}{2 \times (PRESCALER+1) \times F}
\end{equation}


Precisamos agora definir o prescaler. Definimos ele como a raz�o entre o \emph{clock} do \emph{timer} pela frequ�ncia desejada ($\frac{\text{clock}}{2 \times F}$). H� a premissa de que a frequ�ncia desejada n�o ser� maior que a do \emph{clock} do \emph{timer}, pois � imposs�vel contar mais r�pido que isto. Normalmente esta raz�o ($\frac{\text{clock}}{2 \times F}$) ser� um n�mero maior que 255, j� que o clock costuma ser muito mais r�pido, e como o campo onde se registra o valor do prescaler possui apenas 8 bits, frequentemente o prescaler ser� 255.



\section{Mapeamento de Mem�ria}

Por padr�o, as 8 primeiras palavras da mem�ria (ou seja, $8 \times 4 = 32$ bytes) devem possuir instru��es espec�ficas. A primeira palavra (mem�ria posi��o 0) cont�m a primeira instru��o a ser executada, e, nas 7 palavras seguintes, fica a tabela de vetores (\emph{vector table}). Como abaixo da instru��o inicial h� uma tabela que n�o se deseja executar no momento de inicializa��o do sistema, esta primeira instru��o necessariamente � um \emph{jump} para uma outra regi�o, para a� ent�o se iniciar o processo de \emph{boot}. 
As demais 7 palavras, pertencentes � tabela de vetores possuem, similarmente, \emph{jumps} para o c�digo onde o tratador da exce��o se localiza. A primeira instru��o da tabela (posi��o 0x4) deve conter um \emph{jump} o tratador de uma exce��o do tipo undefined instruction, depois, na pr�xima palavra, a software interruption, prefectch abort, data abort, reserved, irq e, finalmente, fiq, nesta ordem. Vide se��es \ref{sec:interrupt} e \ref{sec:operating_modes} para mais detalhes.


%desmontamento do bin�rio da imagem do EPOS
Desmontando-se o bin�rio da imagem produzida na compila��o do EPOS (\emph{dump}), deve-se obter uma sa�da semelhante a esta exemplificada abaixo em seus primeiros 32 bytes:

\label{dump}
\hspace*{-1.8cm}\vbox{
\begin{verbatim}
	00000000 <_vector_table>:
		 0:	e59ff7fc 	ldr	pc, [pc, #2044]	; 804 <_start_addr>
		 4:	e59ff7fc 	ldr	pc, [pc, #2044]	; 808 <_undefined_instruction_addr>
		 8:	e59ff7fc 	ldr	pc, [pc, #2044]	; 80c <_software_interrupt_addr>
		 c:	e59ff7fc 	ldr	pc, [pc, #2044]	; 810 <_prefetch_abort_addr>
		10:	e59ff7fc 	ldr	pc, [pc, #2044]	; 814 <_data_abort_addr>
		14:	e59ff7fc 	ldr	pc, [pc, #2044]	; 818 <_reserved_addr>
		18:	e59ff7fc 	ldr	pc, [pc, #2044]	; 81c <_irq_handler_addr>
		1c:	e59ff7fc 	ldr	pc, [pc, #2044]	; 820 <_fiq_handler_addr>
\end{verbatim}
}

Tamb�m foi necess�rio definir as pilhas (\emph{stacks}) do sistema, assim como reservar um espa�o para a pilha dos tratadores de interrup��o. O \emph{layout} escolhido segue na tabela \ref{tab:stacks}.
\begin{table}[hb]
	\centering
	\begin{tabular}{ccc}
		\hline \hline
		Pilha & Endere�o base & Tamanho m�ximo (bytes)\\[0.5ex]
		\hline
		Supervisor		& \verb+0x00100000+ & 983040\\
		Irq			& \verb+0x00100040+ & 64\\
		System			& \verb+0x00100080+ & 64\\
		Abort			& \verb+0x001000c0+ & 64\\
		Fiq			& \verb+0x00100100+ & 64\\
		Undefined		& \verb+0x00100140+ & 64\\[1ex]
		\hline
	\end{tabular}
	\caption{Pilhas do sistema com seus tamanhos e posi��es.}
	\label{tab:stacks}
\end{table}

Lembrando que pilhas, num sistema operacional, tradicionalmente crescem em dire��o � posi��es menores da mem�ria, por isto que, por exemplo, a pilha Irq possui 64 bytes, j� que $\texttt{0x100040}-\texttt{0x100000} = 40_{16} = 64_{10}$. A pilha do usu�rio, portanto, localiza-se na �ltima posi��o da mem�ria (512 MB neste caso) e cresce para ``baixo'' (posi��es menores de mem�ria) a partir de l�.

%Falar da heap.
%Memory top/base, app_code, app_data...


%%>>>>>continue from here
Restante do mapeamento de mem�ria:
\ref{tab:mem}.
\begin{table}[hb]
	\centering
	\begin{tabular}{ccc}
		\hline \hline
		Dado & Endere�o base & Tamanho m�ximo\\[0.5ex]
		\hline
		Tabela da MMU		& \verb+0x00100144+ & 5242556 bytes\\
		APP\_DATA		& \verb+0x00600000+ & 1mb\\
		SYS\_HEAP		& \verb+0x00700000+ & 32mb\\
		APP\_HEAP		& \verb+0x02700000+ & \\
		APP\_STACK		& \verb+0x1ffffffc+ & \\[1ex]
		\hline
	\end{tabular}
	\caption{Pilhas do sistema com seus tamanhos e posi��es.}
	\label{tab:stacks}
\end{table}


\section{Porte do Controlador de Interrup��es}

%falar sobre os handlers, qual a sequ�ncia de chamadas de fun��o
%int_vector
%os diferentes tipos de interrup��o (abort, prefetch...), dar exemplos de quando s�o gerados
%ICCIAR and ICCEOI register
%spurious interruption 1023
%explicar approach usado em exception.cc

Para se usar o controlador de interrup��es (que ser� referenciado como GIC no restante desta se��o, de \emph{Generic Interrupt Controller}), � necess�rio antes inicializar o distribuidor de interrup��es e as interfaces dos processadores.

� no distribuidor que � determinada a prioridade de cada interrup��o, e onde � decidido se determinada interrup��o deve ou n�o ser encaminhada para a interface de um determinado processador. Todas as interrup��es passam por ele.

A interface dos processadores � por onde os processadores se comunicam com o GIC. Nela o processador confirmar que recebeu a interrup��o (\emph{acknowledge}), indicar que terminou de tratar a mesma, definir prioridades entre diferentes interrup��es, indicar uma pol�tica de preemp��o de interrup��es, ou mesmo desligar esta interface. Como o GIC � dividido logicamente � ilutrado na imagem \ref{img:gic}

\begin{figure}[ht!]
    \centering
    \includegraphics[width=8cm]{figuras/gic}
    \caption{Divis�o l�gica do GIC.}
    \label{img:gic}
\end{figure}

\subsection{Inicializa��o}

Na inicializa��o do distribuidor, atrav�s dos registradores mapeados em mem�ria de configura��o do mesmo, � definido, para cada uma das poss�veis interrup��es, se elas s�o \emph{level-sensitive} ou \emph{edge-triggered}.
Em seguida configura-se a prioridade de cada interrup��o. A princ�pio todas as interrup��es foram definidas como tendo a mesma prioridade, mas isto � configur�vel caso necess�rio.
� configurado ent�o o processador-alvo de cada interrup��o, isto �, para quais interfaces de processador uma determinada interrup��o ser� encaminhada. Finalmente ent�o s�o ativadas as interrup��es.

A inicializa��o da interface do processador � mais simples. Primeiro se configura a m�scara de prioridade da CPU, isto �, qual � o n�vel de prioridade m�nimo que uma interrup��o precisa ter para interromper aquele processador. Na implementa��o esta m�scara est� desativada. Depois configura-se a pol�tica grupos de preemp��o. No GIC � poss�vel separar interrup��es em grupos de preemp��o, onde se define se determinado grupo pode preemptar determinado outro grupo. Todas as interrup��es foram colocadas no mesmo grupo e interrup��es podem ser preemptadas.

Adicionalmente a estas configura��es, � poss�vel de mascaras as interrup��es FIQ e IRQ atrav�s do CPSR (\emph{Current Program Status Register}), alterando-se os bits 6 e 7 dele, para mascarar interrup��es FIQ e IRQ, respectivamente. Normalmente � o que � feito quando � necess�rio mascaras as interrup��es, enquanto se mant�m as configura��es do GIC.

\subsection{Fluxo de execu��o ao se receber uma interrup��o}

O processador, ao se receber uma interrup��o, (e, portanto as interrup��es est�o ativas e n�o mascaradas pela interface ou pelo CPSR), o processador para a execu��o do c�digo que estava executando e ent�o executa a instru��o contida na tabela de vetores (mostrada na p�gina \pageref) correspondente ao tipo de interrup��o recebida. Esta instru��o � um jump para um tratador (\emph{handler}) daquele tipo de interrup��o.

O principal tratador � o tratador de interrup��es IRQ (\verb+irc_handler+), sendo que este precisa ser discutido com mais profundidade. Abaixo segue o c�digo deste tratador:

\begin{verbatim}
 43 void _irq_handler() {
 44   ASMV(
 45   // A few definitions
 46   ".equ ARM_MODE_FIQ,      0x11 \n"
 47   ".equ ARM_MODE_IRQ,      0x12 \n"
 48   ".equ ARM_MODE_SVC,      0x13 \n"
 49   ".equ IRQ_BIT,           0x80 \n"
 50   ".equ FIQ_BIT,           0x40 \n"
 51 
 52   "msr cpsr_c, #ARM_MODE_SVC | IRQ_BIT | FIQ_BIT \n" // go to SVC
 53   // save current context (lr, sp and spsr are banked registers)
 54   "stmfd sp!, {r0-r3,r12,lr,pc}\n"
 55 
 56   "msr cpsr_c, #ARM_MODE_IRQ | IRQ_BIT | FIQ_BIT\n" //go to IRQ
 57 
 58   "sub r0, lr, #4 \n" // return from irq addr
 59   "mrs r1, spsr   \n" // pass irq_spsr to svc r1
 60 
 61   "msr cpsr_c, #ARM_MODE_SVC | IRQ_BIT | FIQ_BIT\n"//go back to SVC
 62   "add r2, sp, #24 \n"  // sp+24 is the position of the saved pc
 63   // save address to return from interrupt into the pc position
 64   // to retore context later on.
 65   "str r0, [r2] \n" 
 66   "stmfd sp!, {r1} \n"   // save irq-spsr
 67       
 68   );    
 69   
 70     
 71   IC::int_handler();
 72     
 73   ASMV(        
 74   "ldmfd sp!, {r0}              \n"
 75   "msr spsr_cfxs, r0 \n" // restore IRQ's spsr value to SVC's spsr
 76             
 77   "ldmfd sp!, {r0-r3,r12,lr,pc}^ \n" // restore context
 78   //the ^ in the end of the above instruction makes the 
 79   //irq_spsr to be restored into svc_cpsr
 80   );
 81 }
\end{verbatim}

Após selecionar qual handler chamar, o processador muda de modo, indo, no caso de uma interrupção IRQ, para o modo de execução IRQ. Neste modo há 3 registradores banqueados: O SPSR, que contém o valor do registrador CPSR imediatamente antes da interrupção, sendo necessário para que seja possível restaurar o valor original do CPSR após tratar a interupção; o LR (link register), que contém o endereço da próxima instrução que seria executada imediatamente antes da interrupção mais 4; e, finalmente, o SP (stack register), que aponta para a pilha própria desde modo (cada modo pode possuir sua própria pilha).

Para evitar desperdício de memória reservando uma pilha própria apenas para este modo, optou-se por não usar uma pilha no modo IRQ, e, no lugar disto, usar sempre a mesma pilha do modo supervisor (que é o modo de exceução do processador quando ele inicia). Para isto, a primeira instrução a se executar é uma mudança de modo para voltar ao modo supervisor, enquanto mantendo novas interrupções desligadas; lá é salvo o contexto na pilha daquele modo. Entretanto para que seja possível restaurar o fluxo de execução no mesmo estado em que o processador estava no momento imediatamente antes da interrupção, é necessário voltar ao modo IRQ para obter-se os valores contidos dos registradores banqueados SPSR e LR; após isto, pode-se então voltar ao modo \emph{supervisor}. Na linha 62 do código é somado 24 à pilha pois lá é a posição de memória onde está salvo o PC após ele ter sido empilhado na linha 54, e deseja-se sobreescrever aquele valor do PC pelo valor que estava contido no LR do modod IRQ (menos 4), pois aquela é a próxima instrução que seria executada antes da interrupção. Feito isto, salva-se o valor do SPSR do modo IRQ no topo da pilha, para ser restaurado ao CPSR mais tarde. Agora que o contexto foi salvo corretamente para ser restaurado, pode-se então chamar um tratador de interrupções genérico (que será discutido mais a frente) e escrito em C++. Após o o \verb+int_handler+ da linha 71 retornar, é feita a restauração do contexto. Primeiro se salva o CPSR no SPSR, na última instrução (ldmfd), na forma em que ela está (com um ^ no final dela e com o PC na lista), ela automaticamente restaurará o valor que está no SPSR para o CPSR. Como o PC está na lista, o fluxo de execução terá retornado a executar as instruções de antes da interrupção ocorrer.

Agora será discutido como que as interrupções são tratadas individualmente. O corpo do \verb+int_handler+ é bastante curto, então vale a pena escreve-lo aqui.

\begin{verbatim}
void Zynq_IC::int_handler()
{	
    unsigned int icciar_value = CPU::in32(IC::GIC_PROC_INTERFACE 
    	| IC::ICCIAR);
	IC::Interrupt_Id id = icciar_value & IC::INTERRUPT_MASK;

	if(id == 1023){
		kout << "Spurious interruption received\n";
		return;
	}
    _vector[id](id);
    CPU::out32(IC::GIC_PROC_INTERFACE | IC::ICCEOI, icciar_value);
}
\end{verbatim}

A primeira coisa que o tratador faz e descobrir qual é o número da interrupção que foi gerada, para assim saber como tratar aquela interrupção. Isto é feito lendo-se o registrador ICCIAR (\emph{Interrupt Acknowledge Register}), que provê o número da interrupção e também o processador endereçado.
É possível que uma interrupção já tenha sido tratada por outro processador, quando isto acontece, o GIC emite uma \emph{Spurious Interruption} para indicar isto. Quando se detecta isto, o tratador não precisa tomar nenhuma outra ação, basta retornar a execução normal.

Com o número da interrupção em mãos, pode-se então chamar o tratador daquele tipo de interrupção. \verb+_vector+ é um vetor de \emph{handlers}, onde para cada posição $i$, existe o tratador da interrupção número $i$. Para sinalizar que uma interrupção foi tratada, deve escrever no registrador ICCEOI (End of Interruption) o número lido no ICCIAR (ou seja, o número da interrupção e processador de destino).


\bibliographystyle{ufscThesis/ufsc-alf}
\bibliography{references}

%--------------------------------------------------------
% Elementos p�s-textuais
%\apendice
%\chapter{Exemplificando um Ap�ndice}
%Texto do Ap�ndice aqui. 

%\anexo
%\chapter{Exemplificando um Anexo}
%Texto do anexo aqui.
\end{document}
